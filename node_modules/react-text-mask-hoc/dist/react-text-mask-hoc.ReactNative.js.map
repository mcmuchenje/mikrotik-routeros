{"version":3,"file":"react-text-mask-hoc.ReactNative.js","sources":["../node_modules/text-mask-core/src/adjustCaretPosition.js","../node_modules/text-mask-core/src/constants.js","../node_modules/text-mask-core/src/utilities.js","../node_modules/text-mask-core/src/conformToMask.js","../src/TextMaskElement.js","../src/createMaskedComponent.js","../src/ReactNativeAdapters.js"],"sourcesContent":["const defaultArray = []\nconst emptyString = ''\n\nexport default function adjustCaretPosition({\n  previousConformedValue = emptyString,\n  previousPlaceholder = emptyString,\n  currentCaretPosition = 0,\n  conformedValue,\n  rawValue,\n  placeholderChar,\n  placeholder,\n  indexesOfPipedChars = defaultArray,\n  caretTrapIndexes = defaultArray\n}) {\n  if (currentCaretPosition === 0) { return 0 }\n\n  // Store lengths for faster performance?\n  const rawValueLength = rawValue.length\n  const previousConformedValueLength = previousConformedValue.length\n  const placeholderLength = placeholder.length\n  const conformedValueLength = conformedValue.length\n\n  // This tells us how long the edit is. If user modified input from `(2__)` to `(243__)`,\n  // we know the user in this instance pasted two characters\n  const editLength = rawValueLength - previousConformedValueLength\n\n  // If the edit length is positive, that means the user is adding characters, not deleting.\n  const isAddition = editLength > 0\n\n  // This is the first raw value the user entered that needs to be conformed to mask\n  const isFirstRawValue = previousConformedValueLength === 0\n\n  // A partial multi-character edit happens when the user makes a partial selection in their\n  // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by\n  // selecting the first 3 digits and pressing backspace.\n  //\n  // Such cases can also happen when the user presses the backspace while holding down the ALT\n  // key.\n  const isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue\n\n  // This algorithm doesn't support all cases of multi-character edits, so we just return\n  // the current caret position.\n  //\n  // This works fine for most cases.\n  if (isPartialMultiCharEdit) { return currentCaretPosition }\n\n  // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter\n  // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the\n  // same as the original `previousConformedValue`. We handle this case differently for caret\n  // positioning.\n  const possiblyHasRejectedChar = isAddition && (\n    previousConformedValue === conformedValue ||\n    conformedValue === placeholder\n  )\n\n  let startingSearchIndex = 0\n  let trackRightCharacter\n  let targetChar\n\n  if (possiblyHasRejectedChar) {\n    startingSearchIndex = currentCaretPosition - editLength\n  } else {\n    // At this point in the algorithm, we want to know where the caret is right before the raw input\n    // has been conformed, and then see if we can find that same spot in the conformed input.\n    //\n    // We do that by seeing what character lies immediately before the caret, and then look for that\n    // same character in the conformed input and place the caret there.\n\n    // First, we need to normalize the inputs so that letter capitalization between raw input and\n    // conformed input wouldn't matter.\n    const normalizedConformedValue = conformedValue.toLowerCase()\n    const normalizedRawValue = rawValue.toLowerCase()\n\n    // Then we take all characters that come before where the caret currently is.\n    const leftHalfChars = normalizedRawValue.substr(0, currentCaretPosition).split(emptyString)\n\n    // Now we find all the characters in the left half that exist in the conformed input\n    // This step ensures that we don't look for a character that was filtered out or rejected by `conformToMask`.\n    const intersection = leftHalfChars.filter((char) => normalizedConformedValue.indexOf(char) !== -1)\n\n    // The last character in the intersection is the character we want to look for in the conformed\n    // value and the one we want to adjust the caret close to\n    targetChar = intersection[intersection.length - 1]\n\n    // Calculate the number of mask characters in the previous placeholder\n    // from the start of the string up to the place where the caret is\n    const previousLeftMaskChars = previousPlaceholder\n      .substr(0, intersection.length)\n      .split(emptyString)\n      .filter(char => char !== placeholderChar)\n      .length\n\n    // Calculate the number of mask characters in the current placeholder\n    // from the start of the string up to the place where the caret is\n    const leftMaskChars = placeholder\n      .substr(0, intersection.length)\n      .split(emptyString)\n      .filter(char => char !== placeholderChar)\n      .length\n\n    // Has the number of mask characters up to the caret changed?\n    const masklengthChanged = leftMaskChars !== previousLeftMaskChars\n\n    // Detect if `targetChar` is a mask character and has moved to the left\n    const targetIsMaskMovingLeft = (\n      previousPlaceholder[intersection.length - 1] !== undefined &&\n      placeholder[intersection.length - 2] !== undefined &&\n      previousPlaceholder[intersection.length - 1] !== placeholderChar &&\n      previousPlaceholder[intersection.length - 1] !== placeholder[intersection.length - 1] &&\n      previousPlaceholder[intersection.length - 1] === placeholder[intersection.length - 2]\n    )\n\n    // If deleting and the `targetChar` `is a mask character and `masklengthChanged` is true\n    // or the mask is moving to the left, we can't use the selected `targetChar` any longer\n    // if we are not at the end of the string.\n    // In this case, change tracking strategy and track the character to the right of the caret.\n    if (\n      !isAddition &&\n      (masklengthChanged || targetIsMaskMovingLeft) &&\n      previousLeftMaskChars > 0 &&\n      placeholder.indexOf(targetChar) > -1 &&\n      rawValue[currentCaretPosition] !== undefined\n    ) {\n      trackRightCharacter = true\n      targetChar = rawValue[currentCaretPosition]\n    }\n\n    // It is possible that `targetChar` will appear multiple times in the conformed value.\n    // We need to know not to select a character that looks like our target character from the placeholder or\n    // the piped characters, so we inspect the piped characters and the placeholder to see if they contain\n    // characters that match our target character.\n\n    // If the `conformedValue` got piped, we need to know which characters were piped in so that when we look for\n    // our `targetChar`, we don't select a piped char by mistake\n    const pipedChars = indexesOfPipedChars.map((index) => normalizedConformedValue[index])\n\n    // We need to know how many times the `targetChar` occurs in the piped characters.\n    const countTargetCharInPipedChars = pipedChars.filter((char) => char === targetChar).length\n\n    // We need to know how many times it occurs in the intersection\n    const countTargetCharInIntersection = intersection.filter((char) => char === targetChar).length\n\n    // We need to know if the placeholder contains characters that look like\n    // our `targetChar`, so we don't select one of those by mistake.\n    const countTargetCharInPlaceholder = placeholder\n      .substr(0, placeholder.indexOf(placeholderChar))\n      .split(emptyString)\n      .filter((char, index) => (\n        // Check if `char` is the same as our `targetChar`, so we account for it\n        char === targetChar &&\n\n        // but also make sure that both the `rawValue` and placeholder don't have the same character at the same\n        // index because if they are equal, that means we are already counting those characters in\n        // `countTargetCharInIntersection`\n        rawValue[index] !== char\n      ))\n      .length\n\n    // The number of times we need to see occurrences of the `targetChar` before we know it is the one we're looking\n    // for is:\n    const requiredNumberOfMatches = (\n      countTargetCharInPlaceholder +\n      countTargetCharInIntersection +\n      countTargetCharInPipedChars +\n      // The character to the right of the caret isn't included in `intersection`\n      // so add one if we are tracking the character to the right\n      (trackRightCharacter ? 1 : 0)\n    )\n\n    // Now we start looking for the location of the `targetChar`.\n    // We keep looping forward and store the index in every iteration. Once we have encountered\n    // enough occurrences of the target character, we break out of the loop\n    // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.\n    let numberOfEncounteredMatches = 0\n    for (let i = 0; i < conformedValueLength; i++) {\n      const conformedValueChar = normalizedConformedValue[i]\n\n      startingSearchIndex = i + 1\n\n      if (conformedValueChar === targetChar) {\n        numberOfEncounteredMatches++\n      }\n\n      if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\n        break\n      }\n    }\n  }\n\n  // At this point, if we simply return `startingSearchIndex` as the adjusted caret position,\n  // most cases would be handled. However, we want to fast forward or rewind the caret to the\n  // closest placeholder character if it happens to be in a non-editable spot. That's what the next\n  // logic is for.\n\n  // In case of addition, we fast forward.\n  if (isAddition) {\n    // We want to remember the last placeholder character encountered so that if the mask\n    // contains more characters after the last placeholder character, we don't forward the caret\n    // that far to the right. Instead, we stop it at the last encountered placeholder character.\n    let lastPlaceholderChar = startingSearchIndex\n\n    for (let i = startingSearchIndex; i <= placeholderLength; i++) {\n      if (placeholder[i] === placeholderChar) {\n        lastPlaceholderChar = i\n      }\n\n      if (\n        // If we're adding, we can position the caret at the next placeholder character.\n        placeholder[i] === placeholderChar ||\n\n        // If a caret trap was set by a mask function, we need to stop at the trap.\n        caretTrapIndexes.indexOf(i) !== -1 ||\n\n        // This is the end of the placeholder. We cannot move any further. Let's put the caret there.\n        i === placeholderLength\n      ) {\n        return lastPlaceholderChar\n      }\n    }\n  } else {\n    // In case of deletion, we rewind.\n    if (trackRightCharacter) {\n      // Searching for the character that was to the right of the caret\n      // We start at `startingSearchIndex` - 1 because it includes one character extra to the right\n      for (let i = startingSearchIndex - 1; i >= 0; i--) {\n        // If tracking the character to the right of the cursor, we move to the left until\n        // we found the character and then place the caret right before it\n\n        if (\n          // `targetChar` should be in `conformedValue`, since it was in `rawValue`, just\n          // to the right of the caret\n          conformedValue[i] === targetChar ||\n\n          // If a caret trap was set by a mask function, we need to stop at the trap.\n          caretTrapIndexes.indexOf(i) !== -1 ||\n\n          // This is the beginning of the placeholder. We cannot move any further.\n          // Let's put the caret there.\n          i === 0\n        ) {\n          return i\n        }\n      }\n    } else {\n      // Searching for the first placeholder or caret trap to the left\n\n      for (let i = startingSearchIndex; i >= 0; i--) {\n        // If we're deleting, we stop the caret right before the placeholder character.\n        // For example, for mask `(111) 11`, current conformed input `(456) 86`. If user\n        // modifies input to `(456 86`. That is, they deleted the `)`, we place the caret\n        // right after the first `6`\n\n        if (\n          // If we're deleting, we can position the caret right before the placeholder character\n          placeholder[i - 1] === placeholderChar ||\n\n          // If a caret trap was set by a mask function, we need to stop at the trap.\n          caretTrapIndexes.indexOf(i) !== -1 ||\n\n          // This is the beginning of the placeholder. We cannot move any further.\n          // Let's put the caret there.\n          i === 0\n        ) {\n          return i\n        }\n      }\n    }\n  }\n}\n","export const placeholderChar = '_'\n","import {placeholderChar as defaultPlaceholderChar} from './constants'\n\nconst emptyArray = []\n\nexport function convertMaskToPlaceholder(mask = emptyArray, placeholderChar = defaultPlaceholderChar) {\n  if (mask.indexOf(placeholderChar) !== -1) {\n    throw new Error(\n      'Placeholder character must not be used as part of the mask. Please specify a character ' +\n      'that is not present in your mask as your placeholder character.\\n\\n' +\n      `The placeholder character that was received is: ${JSON.stringify(placeholderChar)}\\n\\n` +\n      `The mask that was received is: ${JSON.stringify(mask)}`\n    )\n  }\n\n  return mask.map((char) => {\n    return (char instanceof RegExp) ? placeholderChar : char\n  }).join('')\n}\n\nexport function isString(value) {\n  return typeof value === 'string' || value instanceof String\n}\n\nexport function isNumber(value) {\n  return typeof value === 'number' && value.length === undefined && !isNaN(value)\n}\n\nconst strCaretTrap = '[]'\nexport function processCaretTraps(mask) {\n  const indexes = []\n\n  let indexOfCaretTrap\n  while(indexOfCaretTrap = mask.indexOf(strCaretTrap), indexOfCaretTrap !== -1) { // eslint-disable-line\n    indexes.push(indexOfCaretTrap)\n\n    mask.splice(indexOfCaretTrap, 1)\n  }\n\n  return {maskWithoutCaretTraps: mask, indexes}\n}\n","import {convertMaskToPlaceholder} from './utilities'\nimport {placeholderChar as defaultPlaceholderChar} from './constants'\n\nconst emptyString = ''\n\nexport default function conformToMask(rawValue = emptyString, mask = emptyString, config = {}) {\n  // These configurations tell us how to conform the mask\n  const {\n    guide = true,\n    previousConformedValue = emptyString,\n    placeholderChar = defaultPlaceholderChar,\n    placeholder = convertMaskToPlaceholder(mask, placeholderChar),\n    currentCaretPosition,\n    keepCharPositions\n  } = config\n\n  // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n  const suppressGuide = guide === false && previousConformedValue !== undefined\n\n  // Calculate lengths once for performance\n  const rawValueLength = rawValue.length\n  const previousConformedValueLength = previousConformedValue.length\n  const placeholderLength = placeholder.length\n  const maskLength = mask.length\n\n  // This tells us the number of edited characters and the direction in which they were edited (+/-)\n  const editDistance = rawValueLength - previousConformedValueLength\n\n  // In *no guide* mode, we need to know if the user is trying to add a character or not\n  const isAddition = editDistance > 0\n\n  // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n  const indexOfFirstChange = currentCaretPosition + (isAddition ? -editDistance : 0)\n\n  // We're also gonna need the index of last change, which we can derive as follows...\n  const indexOfLastChange = indexOfFirstChange + Math.abs(editDistance)\n\n  // If `conformToMask` is configured to keep character positions, that is, for mask 111, previous value\n  // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of\n  // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be\n  // __3, not _3_ (default behavior)\n  //\n  // The next block of logic handles keeping character positions for the case of deletion. (Keeping\n  // character positions for the case of addition is further down since it is handled differently.)\n  // To do this, we want to compensate for all characters that were deleted\n  if (keepCharPositions === true && !isAddition) {\n    // We will be storing the new placeholder characters in this variable.\n    let compensatingPlaceholderChars = emptyString\n\n    // For every character that was deleted from a placeholder position, we add a placeholder char\n    for (let i = indexOfFirstChange; i < indexOfLastChange; i++) {\n      if (placeholder[i] === placeholderChar) {\n        compensatingPlaceholderChars += placeholderChar\n      }\n    }\n\n    // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters\n    // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters\n    // in their positions.\n    rawValue = (\n      rawValue.slice(0, indexOfFirstChange) +\n      compensatingPlaceholderChars +\n      rawValue.slice(indexOfFirstChange, rawValueLength)\n    )\n  }\n\n  // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have\n  // existed in the previous conformed value. Identifying new and old characters is needed for `conformToMask`\n  // to work if it is configured to keep character positions.\n  const rawValueArr = rawValue\n    .split(emptyString)\n    .map((char, i) => ({char, isNew: i >= indexOfFirstChange && i < indexOfLastChange}))\n\n  // The loop below removes masking characters from user input. For example, for mask\n  // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\n  // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm\n  // then would lay `234` on top of the available placeholder positions in the mask.\n  for (let i = rawValueLength - 1; i >= 0; i--) {\n    const {char} = rawValueArr[i]\n\n    if (char !== placeholderChar) {\n      const shouldOffset = i >= indexOfFirstChange && previousConformedValueLength === maskLength\n\n      if (char === placeholder[(shouldOffset) ? i - editDistance : i]) {\n        rawValueArr.splice(i, 1)\n      }\n    }\n  }\n\n  // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n  let conformedValue = emptyString\n  let someCharsRejected = false\n\n  // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n  placeholderLoop: for (let i = 0; i < placeholderLength; i++) {\n    const charInPlaceholder = placeholder[i]\n\n    // We see one. Let's find out what we can put in it.\n    if (charInPlaceholder === placeholderChar) {\n      // But before that, do we actually have any user characters that need a place?\n      if (rawValueArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (rawValueArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          const {char: rawValueChar, isNew} = rawValueArr.shift()\n\n          // If the character we got from the user input is a placeholder character (which happens\n          // regularly because user input could be something like (540) 90_-____, which includes\n          // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\n          // then we map this placeholder character to the current spot in the placeholder\n          if (rawValueChar === placeholderChar && suppressGuide !== true) {\n            conformedValue += placeholderChar\n\n            // And we go to find the next placeholder character that needs filling\n            continue placeholderLoop\n\n          // Else if, the character we got from the user input is not a placeholder, let's see\n          // if the current position in the mask can accept it.\n          } else if (mask[i].test(rawValueChar)) {\n            // we map the character differently based on whether we are keeping character positions or not.\n            // If any of the conditions below are met, we simply map the raw value character to the\n            // placeholder position.\n            if (\n              keepCharPositions !== true ||\n              isNew === false ||\n              previousConformedValue === emptyString ||\n              guide === false ||\n              !isAddition\n            ) {\n              conformedValue += rawValueChar\n            } else {\n              // We enter this block of code if we are trying to keep character positions and none of the conditions\n              // above is met. In this case, we need to see if there's an available spot for the raw value character\n              // to be mapped to. If we couldn't find a spot, we will discard the character.\n              //\n              // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the\n              // `9`, to the first available placeholder position, but then, there are no more spots available for the\n              // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.\n              const rawValueArrLength = rawValueArr.length\n              let indexOfNextAvailablePlaceholderChar = null\n\n              // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,\n              // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.\n              // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable\n              // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.\n              for (let i = 0; i < rawValueArrLength; i++) {\n                const charData = rawValueArr[i]\n\n                if (charData.char !== placeholderChar && charData.isNew === false) {\n                  break\n                }\n\n                if (charData.char === placeholderChar) {\n                  indexOfNextAvailablePlaceholderChar = i\n                  break\n                }\n              }\n\n              // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.\n              // We can map it. And to keep the character positions, we remove the placeholder character\n              // from the remaining characters\n              if (indexOfNextAvailablePlaceholderChar !== null) {\n                conformedValue += rawValueChar\n                rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1)\n\n              // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to\n              // discard it.\n              } else {\n                i--\n              }\n            }\n\n            // Since we've mapped this placeholder position. We move on to the next one.\n            continue placeholderLoop\n          } else {\n            someCharsRejected = true\n          }\n        }\n      }\n\n      // We reach this point when we've mapped all the user input characters to placeholder\n      // positions in the mask. In *guide* mode, we append the left over characters in the\n      // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\n      //\n      // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\n      if (suppressGuide === false) {\n        conformedValue += placeholder.substr(i, placeholderLength)\n      }\n\n      // And we break\n      break\n\n    // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it\n    // with user input. So we just map it to the final output\n    } else {\n      conformedValue += charInPlaceholder\n    }\n  }\n\n  // The following logic is needed to deal with the case of deletion in *no guide* mode.\n  //\n  // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\n  // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\n  // That's why the logic below finds the last filled placeholder character, and removes everything\n  // from that point on.\n  if (suppressGuide && isAddition === false) {\n    let indexOfLastFilledPlaceholderChar = null\n\n    // Find the last filled placeholder position and substring from there\n    for (let i = 0; i < conformedValue.length; i++) {\n      if (placeholder[i] === placeholderChar) {\n        indexOfLastFilledPlaceholderChar = i\n      }\n    }\n\n    if (indexOfLastFilledPlaceholderChar !== null) {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1)\n    } else {\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedValue = emptyString\n    }\n  }\n\n  return {conformedValue, meta: {someCharsRejected}}\n}\n","/* eslint-disable import/no-extraneous-dependencies */\n\nimport adjustCaretPosition from 'text-mask-core/src/adjustCaretPosition';\nimport conformToMask from 'text-mask-core/src/conformToMask';\nimport {convertMaskToPlaceholder, isString, isNumber, processCaretTraps} from 'text-mask-core/src/utilities';\nimport {placeholderChar as defaultPlaceholderChar} from 'text-mask-core/src/constants';\n\nfunction getSafeRawValue(inputValue) {\n    if (inputValue == null) return '';\n    if (isString(inputValue)) return inputValue;\n    if (isNumber(inputValue)) return String(inputValue);\n\n    throw new Error(\n        \"The 'value' provided to Text Mask needs to be a string or a number. The value \" +\n            `received was:\\n\\n ${JSON.stringify(inputValue)}`\n    );\n}\n\nexport default class TextMaskElement {\n    previousRawValue = undefined;\n    previousConformedValue = undefined;\n    previousPlaceholder = undefined;\n\n    update({\n        value: rawValue,\n        caretPosition: currentCaretPosition,\n        mask: providedMask,\n        guide,\n        pipe,\n        placeholderChar = defaultPlaceholderChar,\n        keepCharPositions = false,\n        showMask = false,\n    }) {\n        // If `rawValue` equals `state.previousConformedValue`, we don't need to change anything. So, we return.\n        // This check is here to handle controlled framework components that repeat the `update` call on every render.\n        if (rawValue === this.previousConformedValue || rawValue === this.previousRawValue) {\n            return null;\n        }\n\n        this.previousRawValue = rawValue;\n\n        // Text Mask accepts masks that are a combination of a `mask` and a `pipe` that work together.\n        // If such a `mask` is passed, we destructure it below, so the rest of the code can work normally\n        // as if a separate `mask` and a `pipe` were passed.\n        if (\n            providedMask != null &&\n            typeof providedMask === 'object' &&\n            providedMask.pipe != null &&\n            providedMask.mask != null\n        ) {\n            /* eslint-disable no-param-reassign */\n            pipe = providedMask.pipe;\n            providedMask = providedMask.mask;\n            /* eslint-enable */\n        }\n\n        // The `placeholder` is an essential piece of how Text Mask works. For a mask like `(111)`,\n        // the placeholder would be `(___)` if the `placeholderChar` is set to `_`.\n        let placeholder;\n\n        // We don't know what the mask would be yet. If it is an array, we take it as is, but if it's a function,\n        // we will have to call that function to get the mask array.\n        let mask;\n\n        // If the provided mask is an array, we can call `convertMaskToPlaceholder` here once and we'll always have the\n        // correct `placeholder`.\n        if (Array.isArray(providedMask)) {\n            placeholder = convertMaskToPlaceholder(providedMask, placeholderChar);\n        }\n\n        // We check the provided `rawValue` before moving further.\n        // If it's something we can't work with `getSafeRawValue` will throw.\n        const safeRawValue = getSafeRawValue(rawValue);\n\n        // In framework components that support reactivity, it's possible to turn off masking by passing\n        // `false` for `mask` after initialization. See https://github.com/text-mask/text-mask/pull/359\n        if (providedMask === false) {\n            return {\n                value: safeRawValue,\n                caretPosition: currentCaretPosition,\n            };\n        }\n\n        let caretTrapIndexes;\n\n        // If the `providedMask` is a function. We need to call it at every `update` to get the `mask` array.\n        // Then we also need to get the `placeholder`\n        if (typeof providedMask === 'function') {\n            mask = providedMask(safeRawValue, {\n                currentCaretPosition,\n                previousConformedValue: this.previousConformedValue,\n                placeholderChar,\n            });\n\n            // disable masking if `mask` is `false`\n            if (mask === false) {\n                return null;\n            }\n\n            // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n            // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return\n            // the indexes of the caret traps.\n            const {maskWithoutCaretTraps, indexes} = processCaretTraps(mask);\n\n            // The processed mask is what we're interested in\n            mask = maskWithoutCaretTraps;\n            // And we need to store these indexes because they're needed by `adjustCaretPosition`\n            caretTrapIndexes = indexes;\n\n            placeholder = convertMaskToPlaceholder(mask, placeholderChar);\n\n            // If the `providedMask` is not a function, we just use it as-is.\n        }\n        else {\n            mask = providedMask;\n        }\n\n        // The following object will be passed to `conformToMask` to determine how the `rawValue` will be conformed\n        const conformToMaskConfig = {\n            previousConformedValue: this.previousConformedValue,\n            guide,\n            placeholderChar,\n            pipe,\n            placeholder,\n            currentCaretPosition,\n            keepCharPositions,\n        };\n\n        // `conformToMask` returns `conformedValue` as part of an object for future API flexibility\n        const {conformedValue} = conformToMask(safeRawValue, mask, conformToMaskConfig);\n\n        // The following few lines are to support the `pipe` feature.\n        const piped = typeof pipe === 'function';\n\n        let pipeResults = {};\n\n        // If `pipe` is a function, we call it.\n        if (piped) {\n            // `pipe` receives the `conformedValue` and the configurations with which `conformToMask` was called.\n            pipeResults = pipe(conformedValue, {rawValue: safeRawValue, ...conformToMaskConfig});\n\n            // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just\n            // return `false` to indicate rejection. Or return just a string when there are no piped characters.\n            // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest\n            // of the code can work with.\n            if (pipeResults === false) {\n                // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`,\n                // and set `rejected` to `true`.\n                pipeResults = {value: this.previousConformedValue, rejected: true};\n            }\n            else if (isString(pipeResults)) {\n                pipeResults = {value: pipeResults};\n            }\n        }\n\n        // Before we proceed, we need to know which conformed value to use, the one returned by the pipe or the one\n        // returned by `conformToMask`.\n        const finalConformedValue = piped ? pipeResults.value : conformedValue;\n\n        // After determining the conformed value, we will need to know where to set\n        // the caret position. `adjustCaretPosition` will tell us.\n        const adjustedCaretPosition = adjustCaretPosition({\n            previousConformedValue: this.previousConformedValue,\n            previousPlaceholder: this.previousPlaceholder,\n            conformedValue: finalConformedValue,\n            placeholder,\n            rawValue: safeRawValue,\n            currentCaretPosition,\n            placeholderChar,\n            indexesOfPipedChars: pipeResults.indexesOfPipedChars,\n            caretTrapIndexes,\n        });\n\n        // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\n        const inputValueShouldBeEmpty = finalConformedValue === placeholder && adjustedCaretPosition === 0;\n        const emptyValue = showMask ? placeholder : '';\n        const inputElementValue = inputValueShouldBeEmpty ? emptyValue : finalConformedValue;\n\n        this.previousConformedValue = inputElementValue; // store value for access for next time\n        this.previousPlaceholder = placeholder;\n\n        return {\n            value: inputElementValue,\n            caretPosition: adjustedCaretPosition,\n        };\n    }\n}\n","/* eslint-disable import/no-extraneous-dependencies */\n\nimport React, {PureComponent} from 'react';\nimport PropTypes from 'prop-types';\nimport TextMaskElement from './TextMaskElement';\n\nexport default WrappedComponent =>\n    class TextMask extends PureComponent {\n        static propTypes = {\n            mask: PropTypes.oneOfType([\n                PropTypes.array,\n                PropTypes.func,\n                PropTypes.bool,\n                PropTypes.shape({\n                    mask: PropTypes.oneOfType([PropTypes.array, PropTypes.func]),\n                    pipe: PropTypes.func,\n                }),\n            ]).isRequired,\n            value: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n            guide: PropTypes.bool,\n            pipe: PropTypes.func,\n            placeholderChar: PropTypes.string,\n            keepCharPositions: PropTypes.bool,\n            showMask: PropTypes.bool,\n            onChange: PropTypes.func,\n            componentRef: PropTypes.func,\n        };\n\n        static defaultProps = {\n            value: '',\n            guide: true,\n            pipe: null,\n            placeholderChar: '_',\n            keepCharPositions: false,\n            showMask: false,\n            onChange: () => {},\n            componentRef: () => {},\n        };\n\n        constructor(props, context) {\n            super(props, context);\n\n            this.component = null;\n            this.textMaskElement = null;\n\n            this.textMaskElement = new TextMaskElement();\n            const nextUpdate = this._update(this.props);\n\n            if (nextUpdate !== null) {\n                this.state = {\n                    value: nextUpdate.value,\n                    caretPosition: nextUpdate.caretPosition,\n                };\n            }\n            else {\n                this.state = {\n                    value: '',\n                    caretPosition: 0,\n                };\n            }\n        }\n\n        componentWillReceiveProps(nextProps) {\n            const nextUpdate = this._update(nextProps);\n            if (nextUpdate !== null) this.setState(nextUpdate);\n        }\n\n        _update = props =>\n            this.textMaskElement.update({\n                value: props.value,\n                caretPosition: this.component != null ? this.component.caretPosition : 0,\n                mask: props.mask,\n                guide: props.guide,\n                pipe: props.pipe,\n                placeholderChar: props.placeholderChar,\n                keepCharPositions: props.keepCharPositions,\n                showMask: props.showMask,\n            });\n\n        _getRef = (comp) => {\n            if (comp) {\n                this.props.componentRef(comp);\n                this.component = comp;\n            }\n        };\n\n        _onChange = (event) => {\n            if (event) {\n                const rawValue = event.target != null && typeof event.target === 'object'\n                    ? event.target.value\n                    : event.text;\n                const nextUpdate = this._update({...this.props, value: rawValue});\n                if (nextUpdate !== null) {\n                    this.setState(nextUpdate);\n                }\n                this.props.onChange(event);\n            }\n        };\n\n        render() {\n            const {\n                value,\n                mask,\n                guide,\n                pipe,\n                placeholderChar,\n                keepCharPositions,\n                showMask,\n                componentRef,\n                onChange,\n                ...rest\n            } = this.props;\n\n            return (\n                <WrappedComponent\n                    {...rest}\n                    value={this.state.value}\n                    caretPosition={this.state.caretPosition}\n                    onChange={this._onChange}\n                    ref={this._getRef}\n                />\n            );\n        }\n\n        // Callback input functions.\n\n        // focus() {\n        //     this.component.focus();\n        // }\n        //\n        // blur() {\n        //     this.component.blur();\n        // }\n    };\n","/* eslint-disable import/no-extraneous-dependencies, react/no-multi-comp */\n\nimport React, {PureComponent} from 'react';\nimport {Text, TextInput} from 'react-native';\nimport PropTypes from 'prop-types';\n\nexport class TextInputAdapter extends PureComponent {\n    static propTypes = {\n        value: PropTypes.string.isRequired,\n        caretPosition: PropTypes.number.isRequired,\n        onChange: PropTypes.func.isRequired,\n    };\n\n    _lastOnChangeEvent;\n    _selection;\n    _wait = false;\n\n    get caretPosition() {\n        return this._selection ? this._selection.end : 0;\n    }\n\n    _getRef = (ref) => {\n        this.input = ref;\n    };\n\n    _onChange = ({nativeEvent}) => {\n        this._lastOnChangeEvent = nativeEvent;\n    };\n\n    _onSelectionChange = ({nativeEvent}) => {\n        // Throttle events because they are called multiple times for an unknown reason.\n        if (this._wait) return;\n        this._wait = true;\n        setTimeout(() => {\n            this._wait = false;\n        }, 100);\n\n        // onChange() runs before onSelectionChange(), so when text-mask gets selection\n        // it's a previous value instead of the current one.\n\n        this._selection = nativeEvent.selection;\n        if (this._lastOnChangeEvent && this._lastOnChangeEvent.text !== this.props.value) {\n            this.props.onChange(this._lastOnChangeEvent);\n            this._lastOnChangeEvent = null;\n        }\n        else {\n            this.forceUpdate();\n        }\n    };\n\n    render() {\n        const {caretPosition, onChange, ...rest} = this.props;\n\n        return (\n            <TextInput\n                {...rest}\n                ref={this._getRef}\n                selection={{start: caretPosition, end: caretPosition}}\n                onChange={this._onChange}\n                onSelectionChange={this._onSelectionChange}\n            />\n        );\n    }\n}\n\nexport class TextAdapter extends PureComponent {\n    static propTypes = {\n        value: PropTypes.string.isRequired,\n        caretPosition: PropTypes.number.isRequired,\n        onChange: PropTypes.func.isRequired,\n    };\n\n    // eslint-disable-next-line class-methods-use-this\n    get caretPosition() {\n        return 0;\n    }\n\n    render() {\n        const {value, caretPosition, onChange, ...rest} = this.props;\n\n        return <Text {...rest}>{value}</Text>;\n    }\n}\n"],"names":["defaultArray","emptyString","adjustCaretPosition","previousConformedValue","previousPlaceholder","currentCaretPosition","conformedValue","rawValue","placeholderChar","placeholder","indexesOfPipedChars","caretTrapIndexes","rawValueLength","length","previousConformedValueLength","placeholderLength","conformedValueLength","editLength","isAddition","isFirstRawValue","isPartialMultiCharEdit","possiblyHasRejectedChar","startingSearchIndex","trackRightCharacter","targetChar","normalizedConformedValue","toLowerCase","normalizedRawValue","leftHalfChars","substr","split","intersection","filter","char","indexOf","previousLeftMaskChars","leftMaskChars","masklengthChanged","targetIsMaskMovingLeft","undefined","pipedChars","map","index","countTargetCharInPipedChars","countTargetCharInIntersection","countTargetCharInPlaceholder","requiredNumberOfMatches","numberOfEncounteredMatches","i","conformedValueChar","lastPlaceholderChar","emptyArray","convertMaskToPlaceholder","mask","defaultPlaceholderChar","Error","JSON","stringify","RegExp","join","isString","value","String","isNumber","isNaN","strCaretTrap","processCaretTraps","indexes","indexOfCaretTrap","push","splice","maskWithoutCaretTraps","conformToMask","config","guide","keepCharPositions","suppressGuide","maskLength","editDistance","indexOfFirstChange","indexOfLastChange","Math","abs","compensatingPlaceholderChars","slice","rawValueArr","isNew","shouldOffset","someCharsRejected","charInPlaceholder","shift","rawValueChar","placeholderLoop","test","rawValueArrLength","indexOfNextAvailablePlaceholderChar","charData","indexOfLastFilledPlaceholderChar","meta","getSafeRawValue","inputValue","TextMaskElement","previousRawValue","caretPosition","providedMask","pipe","showMask","Array","isArray","safeRawValue","conformToMaskConfig","piped","pipeResults","rejected","finalConformedValue","adjustedCaretPosition","inputValueShouldBeEmpty","emptyValue","inputElementValue","props","context","component","textMaskElement","nextUpdate","_update","state","nextProps","setState","componentRef","onChange","rest","_onChange","_getRef","PureComponent","propTypes","PropTypes","oneOfType","array","func","bool","shape","isRequired","string","number","defaultProps","update","comp","event","target","babelHelpers.typeof","text","TextInputAdapter","_wait","ref","input","nativeEvent","_lastOnChangeEvent","_onSelectionChange","_selection","selection","forceUpdate","start","end","TextAdapter"],"mappings":"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"}